<#
if (string.IsNullOrEmpty(DllName))
	DllName = "bass" + ID.ToLower();

if (string.IsNullOrEmpty(LibraryName))
	LibraryName = string.IsNullOrEmpty(ID) ? "Bass" : "Bass" + Char.ToUpper(ID[0]) + ID.Substring(1).ToLower();

if (!string.IsNullOrEmpty(ID))
    ID += "_";

var HasCondition = !string.IsNullOrEmpty(Condition);

if (HasCondition) WriteLine("#if " + Condition);
#>

using System;
using System.Runtime.InteropServices;

namespace ManagedBass<# if (!string.IsNullOrEmpty(Namespace)) WriteLine("." + Namespace); #>
{
    <# if (!string.IsNullOrEmpty(DocSummary)) { #>
	/// <summary>
    /// <#= DocSummary #>
    /// </summary> 
    /// <remarks>
    /// <#= DocRemarks #>
    /// </remarks>
	<# } #>
    public static <#= IsPartial ? "partial" : "" #> class <#= LibraryName #>
    {
#if __IOS__
        const string DllName = "__internal";
#else
        const string DllName = "<#= DllName #>";
#endif

#if __ANDROID__ || WINDOWS || LINUX || __MAC__
        static IntPtr hLib;
        
        /// <summary>
        /// Load from a folder other than the Current Directory.
        /// <param name="Folder">If null (default), Load from Current Directory</param>
        /// </summary>
        public static void Load(string Folder = null) => hLib = DynamicLibrary.Load(DllName, Folder);

        public static void Unload() => DynamicLibrary.Unload(hLib);
#endif

        <# if (!string.IsNullOrEmpty(ID)) { #>public static readonly Plugin Plugin = new Plugin(DllName);<# } #>
		
        <#= Embed #>

        [DllImport(DllName, CharSet = CharSet.Unicode)]
        static extern int BASS_<#= ID #>StreamCreateFile(bool mem, string file, long offset, long length, BassFlags flags);

        [DllImport(DllName)]
        static extern int BASS_<#= ID #>StreamCreateFile(bool mem, IntPtr file, long offset, long length, BassFlags flags);

		<#= FileDoc #>
        public static int CreateStream(string File, long Offset = 0, long Length = 0, BassFlags Flags = BassFlags.Default)
        {
            return BASS_<#= ID #>StreamCreateFile(false, File, Offset, Length, Flags | BassFlags.Unicode);
        }

		<#= MemDoc #>
        public static int CreateStream(IntPtr Memory, long Offset, long Length, BassFlags Flags = BassFlags.Default)
        {
            return BASS_<#= ID #>StreamCreateFile(true, new IntPtr(Memory.ToInt64() + Offset), 0, Length, Flags);
        }

		<#= ByteDoc #>
        public static int CreateStream(byte[] Memory, long Offset, long Length, BassFlags Flags)
        {
            var GCPin = GCHandle.Alloc(Memory, GCHandleType.Pinned);

            var Handle = CreateStream(GCPin.AddrOfPinnedObject(), Offset, Length, Flags);

            if (Handle == 0) GCPin.Free();
            else Bass.ChannelSetSync(Handle, SyncFlags.Free, 0, (a, b, c, d) => GCPin.Free());

            return Handle;
        }
        
        [DllImport(DllName)]
        static extern int BASS_<#= ID #>StreamCreateFileUser(StreamSystem system, BassFlags flags, [In, Out] FileProcedures procs, IntPtr user);

		<#= UserDoc #>
        public static int CreateStream(StreamSystem system, BassFlags flags, FileProcedures procs, IntPtr user = default(IntPtr))
        {
            var h = BASS_<#= ID #>StreamCreateFileUser(system, flags, procs, user);

            if (h != 0)
                Extensions.ChannelReferences.Add(h, 0, procs);

            return h;
        }

        [DllImport(DllName, CharSet = CharSet.Unicode)]
        static extern int BASS_<#= ID #>StreamCreateURL(string Url, int Offset, BassFlags Flags, DownloadProcedure Procedure, IntPtr User);

		<#= UrlDoc #>
        public static int CreateStream(string Url, int Offset, BassFlags Flags, DownloadProcedure Procedure, IntPtr User = default(IntPtr))
        {
            var h = BASS_<#= ID #>StreamCreateURL(Url, Offset, Flags | BassFlags.Unicode, Procedure, User);

            if (h != 0)
                Extensions.ChannelReferences.Add(h, 0, Procedure);

            return h;
        }
    }
}
<# if (HasCondition) Write("#endif"); #>